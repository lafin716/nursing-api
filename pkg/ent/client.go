// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"nursing_api/pkg/ent/migrate"

	"nursing_api/pkg/ent/medicine"
	"nursing_api/pkg/ent/prescription"
	"nursing_api/pkg/ent/prescriptionitem"
	"nursing_api/pkg/ent/takehistoryitem"
	"nursing_api/pkg/ent/takehistorymemo"
	"nursing_api/pkg/ent/timezone"
	"nursing_api/pkg/ent/token"
	"nursing_api/pkg/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Medicine is the client for interacting with the Medicine builders.
	Medicine *MedicineClient
	// Prescription is the client for interacting with the Prescription builders.
	Prescription *PrescriptionClient
	// PrescriptionItem is the client for interacting with the PrescriptionItem builders.
	PrescriptionItem *PrescriptionItemClient
	// TakeHistoryItem is the client for interacting with the TakeHistoryItem builders.
	TakeHistoryItem *TakeHistoryItemClient
	// TakeHistoryMemo is the client for interacting with the TakeHistoryMemo builders.
	TakeHistoryMemo *TakeHistoryMemoClient
	// TimeZone is the client for interacting with the TimeZone builders.
	TimeZone *TimeZoneClient
	// Token is the client for interacting with the Token builders.
	Token *TokenClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Medicine = NewMedicineClient(c.config)
	c.Prescription = NewPrescriptionClient(c.config)
	c.PrescriptionItem = NewPrescriptionItemClient(c.config)
	c.TakeHistoryItem = NewTakeHistoryItemClient(c.config)
	c.TakeHistoryMemo = NewTakeHistoryMemoClient(c.config)
	c.TimeZone = NewTimeZoneClient(c.config)
	c.Token = NewTokenClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Medicine:         NewMedicineClient(cfg),
		Prescription:     NewPrescriptionClient(cfg),
		PrescriptionItem: NewPrescriptionItemClient(cfg),
		TakeHistoryItem:  NewTakeHistoryItemClient(cfg),
		TakeHistoryMemo:  NewTakeHistoryMemoClient(cfg),
		TimeZone:         NewTimeZoneClient(cfg),
		Token:            NewTokenClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Medicine:         NewMedicineClient(cfg),
		Prescription:     NewPrescriptionClient(cfg),
		PrescriptionItem: NewPrescriptionItemClient(cfg),
		TakeHistoryItem:  NewTakeHistoryItemClient(cfg),
		TakeHistoryMemo:  NewTakeHistoryMemoClient(cfg),
		TimeZone:         NewTimeZoneClient(cfg),
		Token:            NewTokenClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Medicine.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Medicine, c.Prescription, c.PrescriptionItem, c.TakeHistoryItem,
		c.TakeHistoryMemo, c.TimeZone, c.Token, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Medicine, c.Prescription, c.PrescriptionItem, c.TakeHistoryItem,
		c.TakeHistoryMemo, c.TimeZone, c.Token, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *MedicineMutation:
		return c.Medicine.mutate(ctx, m)
	case *PrescriptionMutation:
		return c.Prescription.mutate(ctx, m)
	case *PrescriptionItemMutation:
		return c.PrescriptionItem.mutate(ctx, m)
	case *TakeHistoryItemMutation:
		return c.TakeHistoryItem.mutate(ctx, m)
	case *TakeHistoryMemoMutation:
		return c.TakeHistoryMemo.mutate(ctx, m)
	case *TimeZoneMutation:
		return c.TimeZone.mutate(ctx, m)
	case *TokenMutation:
		return c.Token.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// MedicineClient is a client for the Medicine schema.
type MedicineClient struct {
	config
}

// NewMedicineClient returns a client for the Medicine from the given config.
func NewMedicineClient(c config) *MedicineClient {
	return &MedicineClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `medicine.Hooks(f(g(h())))`.
func (c *MedicineClient) Use(hooks ...Hook) {
	c.hooks.Medicine = append(c.hooks.Medicine, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `medicine.Intercept(f(g(h())))`.
func (c *MedicineClient) Intercept(interceptors ...Interceptor) {
	c.inters.Medicine = append(c.inters.Medicine, interceptors...)
}

// Create returns a builder for creating a Medicine entity.
func (c *MedicineClient) Create() *MedicineCreate {
	mutation := newMedicineMutation(c.config, OpCreate)
	return &MedicineCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Medicine entities.
func (c *MedicineClient) CreateBulk(builders ...*MedicineCreate) *MedicineCreateBulk {
	return &MedicineCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MedicineClient) MapCreateBulk(slice any, setFunc func(*MedicineCreate, int)) *MedicineCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MedicineCreateBulk{err: fmt.Errorf("calling to MedicineClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MedicineCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MedicineCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Medicine.
func (c *MedicineClient) Update() *MedicineUpdate {
	mutation := newMedicineMutation(c.config, OpUpdate)
	return &MedicineUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MedicineClient) UpdateOne(m *Medicine) *MedicineUpdateOne {
	mutation := newMedicineMutation(c.config, OpUpdateOne, withMedicine(m))
	return &MedicineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MedicineClient) UpdateOneID(id uuid.UUID) *MedicineUpdateOne {
	mutation := newMedicineMutation(c.config, OpUpdateOne, withMedicineID(id))
	return &MedicineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Medicine.
func (c *MedicineClient) Delete() *MedicineDelete {
	mutation := newMedicineMutation(c.config, OpDelete)
	return &MedicineDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MedicineClient) DeleteOne(m *Medicine) *MedicineDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MedicineClient) DeleteOneID(id uuid.UUID) *MedicineDeleteOne {
	builder := c.Delete().Where(medicine.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MedicineDeleteOne{builder}
}

// Query returns a query builder for Medicine.
func (c *MedicineClient) Query() *MedicineQuery {
	return &MedicineQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedicine},
		inters: c.Interceptors(),
	}
}

// Get returns a Medicine entity by its id.
func (c *MedicineClient) Get(ctx context.Context, id uuid.UUID) (*Medicine, error) {
	return c.Query().Where(medicine.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MedicineClient) GetX(ctx context.Context, id uuid.UUID) *Medicine {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MedicineClient) Hooks() []Hook {
	return c.hooks.Medicine
}

// Interceptors returns the client interceptors.
func (c *MedicineClient) Interceptors() []Interceptor {
	return c.inters.Medicine
}

func (c *MedicineClient) mutate(ctx context.Context, m *MedicineMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MedicineCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MedicineUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MedicineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MedicineDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Medicine mutation op: %q", m.Op())
	}
}

// PrescriptionClient is a client for the Prescription schema.
type PrescriptionClient struct {
	config
}

// NewPrescriptionClient returns a client for the Prescription from the given config.
func NewPrescriptionClient(c config) *PrescriptionClient {
	return &PrescriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `prescription.Hooks(f(g(h())))`.
func (c *PrescriptionClient) Use(hooks ...Hook) {
	c.hooks.Prescription = append(c.hooks.Prescription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `prescription.Intercept(f(g(h())))`.
func (c *PrescriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Prescription = append(c.inters.Prescription, interceptors...)
}

// Create returns a builder for creating a Prescription entity.
func (c *PrescriptionClient) Create() *PrescriptionCreate {
	mutation := newPrescriptionMutation(c.config, OpCreate)
	return &PrescriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Prescription entities.
func (c *PrescriptionClient) CreateBulk(builders ...*PrescriptionCreate) *PrescriptionCreateBulk {
	return &PrescriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PrescriptionClient) MapCreateBulk(slice any, setFunc func(*PrescriptionCreate, int)) *PrescriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PrescriptionCreateBulk{err: fmt.Errorf("calling to PrescriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PrescriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PrescriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Prescription.
func (c *PrescriptionClient) Update() *PrescriptionUpdate {
	mutation := newPrescriptionMutation(c.config, OpUpdate)
	return &PrescriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PrescriptionClient) UpdateOne(pr *Prescription) *PrescriptionUpdateOne {
	mutation := newPrescriptionMutation(c.config, OpUpdateOne, withPrescription(pr))
	return &PrescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PrescriptionClient) UpdateOneID(id uuid.UUID) *PrescriptionUpdateOne {
	mutation := newPrescriptionMutation(c.config, OpUpdateOne, withPrescriptionID(id))
	return &PrescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Prescription.
func (c *PrescriptionClient) Delete() *PrescriptionDelete {
	mutation := newPrescriptionMutation(c.config, OpDelete)
	return &PrescriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PrescriptionClient) DeleteOne(pr *Prescription) *PrescriptionDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PrescriptionClient) DeleteOneID(id uuid.UUID) *PrescriptionDeleteOne {
	builder := c.Delete().Where(prescription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PrescriptionDeleteOne{builder}
}

// Query returns a query builder for Prescription.
func (c *PrescriptionClient) Query() *PrescriptionQuery {
	return &PrescriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrescription},
		inters: c.Interceptors(),
	}
}

// Get returns a Prescription entity by its id.
func (c *PrescriptionClient) Get(ctx context.Context, id uuid.UUID) (*Prescription, error) {
	return c.Query().Where(prescription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PrescriptionClient) GetX(ctx context.Context, id uuid.UUID) *Prescription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrescriptionItems queries the prescription_items edge of a Prescription.
func (c *PrescriptionClient) QueryPrescriptionItems(pr *Prescription) *PrescriptionItemQuery {
	query := (&PrescriptionItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prescription.Table, prescription.FieldID, id),
			sqlgraph.To(prescriptionitem.Table, prescriptionitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, prescription.PrescriptionItemsTable, prescription.PrescriptionItemsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PrescriptionClient) Hooks() []Hook {
	return c.hooks.Prescription
}

// Interceptors returns the client interceptors.
func (c *PrescriptionClient) Interceptors() []Interceptor {
	return c.inters.Prescription
}

func (c *PrescriptionClient) mutate(ctx context.Context, m *PrescriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PrescriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PrescriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PrescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PrescriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Prescription mutation op: %q", m.Op())
	}
}

// PrescriptionItemClient is a client for the PrescriptionItem schema.
type PrescriptionItemClient struct {
	config
}

// NewPrescriptionItemClient returns a client for the PrescriptionItem from the given config.
func NewPrescriptionItemClient(c config) *PrescriptionItemClient {
	return &PrescriptionItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `prescriptionitem.Hooks(f(g(h())))`.
func (c *PrescriptionItemClient) Use(hooks ...Hook) {
	c.hooks.PrescriptionItem = append(c.hooks.PrescriptionItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `prescriptionitem.Intercept(f(g(h())))`.
func (c *PrescriptionItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.PrescriptionItem = append(c.inters.PrescriptionItem, interceptors...)
}

// Create returns a builder for creating a PrescriptionItem entity.
func (c *PrescriptionItemClient) Create() *PrescriptionItemCreate {
	mutation := newPrescriptionItemMutation(c.config, OpCreate)
	return &PrescriptionItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PrescriptionItem entities.
func (c *PrescriptionItemClient) CreateBulk(builders ...*PrescriptionItemCreate) *PrescriptionItemCreateBulk {
	return &PrescriptionItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PrescriptionItemClient) MapCreateBulk(slice any, setFunc func(*PrescriptionItemCreate, int)) *PrescriptionItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PrescriptionItemCreateBulk{err: fmt.Errorf("calling to PrescriptionItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PrescriptionItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PrescriptionItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PrescriptionItem.
func (c *PrescriptionItemClient) Update() *PrescriptionItemUpdate {
	mutation := newPrescriptionItemMutation(c.config, OpUpdate)
	return &PrescriptionItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PrescriptionItemClient) UpdateOne(pi *PrescriptionItem) *PrescriptionItemUpdateOne {
	mutation := newPrescriptionItemMutation(c.config, OpUpdateOne, withPrescriptionItem(pi))
	return &PrescriptionItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PrescriptionItemClient) UpdateOneID(id uuid.UUID) *PrescriptionItemUpdateOne {
	mutation := newPrescriptionItemMutation(c.config, OpUpdateOne, withPrescriptionItemID(id))
	return &PrescriptionItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PrescriptionItem.
func (c *PrescriptionItemClient) Delete() *PrescriptionItemDelete {
	mutation := newPrescriptionItemMutation(c.config, OpDelete)
	return &PrescriptionItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PrescriptionItemClient) DeleteOne(pi *PrescriptionItem) *PrescriptionItemDeleteOne {
	return c.DeleteOneID(pi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PrescriptionItemClient) DeleteOneID(id uuid.UUID) *PrescriptionItemDeleteOne {
	builder := c.Delete().Where(prescriptionitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PrescriptionItemDeleteOne{builder}
}

// Query returns a query builder for PrescriptionItem.
func (c *PrescriptionItemClient) Query() *PrescriptionItemQuery {
	return &PrescriptionItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrescriptionItem},
		inters: c.Interceptors(),
	}
}

// Get returns a PrescriptionItem entity by its id.
func (c *PrescriptionItemClient) Get(ctx context.Context, id uuid.UUID) (*PrescriptionItem, error) {
	return c.Query().Where(prescriptionitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PrescriptionItemClient) GetX(ctx context.Context, id uuid.UUID) *PrescriptionItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrescription queries the prescription edge of a PrescriptionItem.
func (c *PrescriptionItemClient) QueryPrescription(pi *PrescriptionItem) *PrescriptionQuery {
	query := (&PrescriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prescriptionitem.Table, prescriptionitem.FieldID, id),
			sqlgraph.To(prescription.Table, prescription.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, prescriptionitem.PrescriptionTable, prescriptionitem.PrescriptionColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTakeHistoryItem queries the take_history_item edge of a PrescriptionItem.
func (c *PrescriptionItemClient) QueryTakeHistoryItem(pi *PrescriptionItem) *TakeHistoryItemQuery {
	query := (&TakeHistoryItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prescriptionitem.Table, prescriptionitem.FieldID, id),
			sqlgraph.To(takehistoryitem.Table, takehistoryitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, prescriptionitem.TakeHistoryItemTable, prescriptionitem.TakeHistoryItemColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PrescriptionItemClient) Hooks() []Hook {
	return c.hooks.PrescriptionItem
}

// Interceptors returns the client interceptors.
func (c *PrescriptionItemClient) Interceptors() []Interceptor {
	return c.inters.PrescriptionItem
}

func (c *PrescriptionItemClient) mutate(ctx context.Context, m *PrescriptionItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PrescriptionItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PrescriptionItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PrescriptionItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PrescriptionItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PrescriptionItem mutation op: %q", m.Op())
	}
}

// TakeHistoryItemClient is a client for the TakeHistoryItem schema.
type TakeHistoryItemClient struct {
	config
}

// NewTakeHistoryItemClient returns a client for the TakeHistoryItem from the given config.
func NewTakeHistoryItemClient(c config) *TakeHistoryItemClient {
	return &TakeHistoryItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `takehistoryitem.Hooks(f(g(h())))`.
func (c *TakeHistoryItemClient) Use(hooks ...Hook) {
	c.hooks.TakeHistoryItem = append(c.hooks.TakeHistoryItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `takehistoryitem.Intercept(f(g(h())))`.
func (c *TakeHistoryItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.TakeHistoryItem = append(c.inters.TakeHistoryItem, interceptors...)
}

// Create returns a builder for creating a TakeHistoryItem entity.
func (c *TakeHistoryItemClient) Create() *TakeHistoryItemCreate {
	mutation := newTakeHistoryItemMutation(c.config, OpCreate)
	return &TakeHistoryItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TakeHistoryItem entities.
func (c *TakeHistoryItemClient) CreateBulk(builders ...*TakeHistoryItemCreate) *TakeHistoryItemCreateBulk {
	return &TakeHistoryItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TakeHistoryItemClient) MapCreateBulk(slice any, setFunc func(*TakeHistoryItemCreate, int)) *TakeHistoryItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TakeHistoryItemCreateBulk{err: fmt.Errorf("calling to TakeHistoryItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TakeHistoryItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TakeHistoryItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TakeHistoryItem.
func (c *TakeHistoryItemClient) Update() *TakeHistoryItemUpdate {
	mutation := newTakeHistoryItemMutation(c.config, OpUpdate)
	return &TakeHistoryItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TakeHistoryItemClient) UpdateOne(thi *TakeHistoryItem) *TakeHistoryItemUpdateOne {
	mutation := newTakeHistoryItemMutation(c.config, OpUpdateOne, withTakeHistoryItem(thi))
	return &TakeHistoryItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TakeHistoryItemClient) UpdateOneID(id uuid.UUID) *TakeHistoryItemUpdateOne {
	mutation := newTakeHistoryItemMutation(c.config, OpUpdateOne, withTakeHistoryItemID(id))
	return &TakeHistoryItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TakeHistoryItem.
func (c *TakeHistoryItemClient) Delete() *TakeHistoryItemDelete {
	mutation := newTakeHistoryItemMutation(c.config, OpDelete)
	return &TakeHistoryItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TakeHistoryItemClient) DeleteOne(thi *TakeHistoryItem) *TakeHistoryItemDeleteOne {
	return c.DeleteOneID(thi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TakeHistoryItemClient) DeleteOneID(id uuid.UUID) *TakeHistoryItemDeleteOne {
	builder := c.Delete().Where(takehistoryitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TakeHistoryItemDeleteOne{builder}
}

// Query returns a query builder for TakeHistoryItem.
func (c *TakeHistoryItemClient) Query() *TakeHistoryItemQuery {
	return &TakeHistoryItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTakeHistoryItem},
		inters: c.Interceptors(),
	}
}

// Get returns a TakeHistoryItem entity by its id.
func (c *TakeHistoryItemClient) Get(ctx context.Context, id uuid.UUID) (*TakeHistoryItem, error) {
	return c.Query().Where(takehistoryitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TakeHistoryItemClient) GetX(ctx context.Context, id uuid.UUID) *TakeHistoryItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrescriptionItem queries the prescription_item edge of a TakeHistoryItem.
func (c *TakeHistoryItemClient) QueryPrescriptionItem(thi *TakeHistoryItem) *PrescriptionItemQuery {
	query := (&PrescriptionItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := thi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(takehistoryitem.Table, takehistoryitem.FieldID, id),
			sqlgraph.To(prescriptionitem.Table, prescriptionitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, takehistoryitem.PrescriptionItemTable, takehistoryitem.PrescriptionItemColumn),
		)
		fromV = sqlgraph.Neighbors(thi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TakeHistoryItemClient) Hooks() []Hook {
	return c.hooks.TakeHistoryItem
}

// Interceptors returns the client interceptors.
func (c *TakeHistoryItemClient) Interceptors() []Interceptor {
	return c.inters.TakeHistoryItem
}

func (c *TakeHistoryItemClient) mutate(ctx context.Context, m *TakeHistoryItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TakeHistoryItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TakeHistoryItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TakeHistoryItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TakeHistoryItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TakeHistoryItem mutation op: %q", m.Op())
	}
}

// TakeHistoryMemoClient is a client for the TakeHistoryMemo schema.
type TakeHistoryMemoClient struct {
	config
}

// NewTakeHistoryMemoClient returns a client for the TakeHistoryMemo from the given config.
func NewTakeHistoryMemoClient(c config) *TakeHistoryMemoClient {
	return &TakeHistoryMemoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `takehistorymemo.Hooks(f(g(h())))`.
func (c *TakeHistoryMemoClient) Use(hooks ...Hook) {
	c.hooks.TakeHistoryMemo = append(c.hooks.TakeHistoryMemo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `takehistorymemo.Intercept(f(g(h())))`.
func (c *TakeHistoryMemoClient) Intercept(interceptors ...Interceptor) {
	c.inters.TakeHistoryMemo = append(c.inters.TakeHistoryMemo, interceptors...)
}

// Create returns a builder for creating a TakeHistoryMemo entity.
func (c *TakeHistoryMemoClient) Create() *TakeHistoryMemoCreate {
	mutation := newTakeHistoryMemoMutation(c.config, OpCreate)
	return &TakeHistoryMemoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TakeHistoryMemo entities.
func (c *TakeHistoryMemoClient) CreateBulk(builders ...*TakeHistoryMemoCreate) *TakeHistoryMemoCreateBulk {
	return &TakeHistoryMemoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TakeHistoryMemoClient) MapCreateBulk(slice any, setFunc func(*TakeHistoryMemoCreate, int)) *TakeHistoryMemoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TakeHistoryMemoCreateBulk{err: fmt.Errorf("calling to TakeHistoryMemoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TakeHistoryMemoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TakeHistoryMemoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TakeHistoryMemo.
func (c *TakeHistoryMemoClient) Update() *TakeHistoryMemoUpdate {
	mutation := newTakeHistoryMemoMutation(c.config, OpUpdate)
	return &TakeHistoryMemoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TakeHistoryMemoClient) UpdateOne(thm *TakeHistoryMemo) *TakeHistoryMemoUpdateOne {
	mutation := newTakeHistoryMemoMutation(c.config, OpUpdateOne, withTakeHistoryMemo(thm))
	return &TakeHistoryMemoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TakeHistoryMemoClient) UpdateOneID(id uuid.UUID) *TakeHistoryMemoUpdateOne {
	mutation := newTakeHistoryMemoMutation(c.config, OpUpdateOne, withTakeHistoryMemoID(id))
	return &TakeHistoryMemoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TakeHistoryMemo.
func (c *TakeHistoryMemoClient) Delete() *TakeHistoryMemoDelete {
	mutation := newTakeHistoryMemoMutation(c.config, OpDelete)
	return &TakeHistoryMemoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TakeHistoryMemoClient) DeleteOne(thm *TakeHistoryMemo) *TakeHistoryMemoDeleteOne {
	return c.DeleteOneID(thm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TakeHistoryMemoClient) DeleteOneID(id uuid.UUID) *TakeHistoryMemoDeleteOne {
	builder := c.Delete().Where(takehistorymemo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TakeHistoryMemoDeleteOne{builder}
}

// Query returns a query builder for TakeHistoryMemo.
func (c *TakeHistoryMemoClient) Query() *TakeHistoryMemoQuery {
	return &TakeHistoryMemoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTakeHistoryMemo},
		inters: c.Interceptors(),
	}
}

// Get returns a TakeHistoryMemo entity by its id.
func (c *TakeHistoryMemoClient) Get(ctx context.Context, id uuid.UUID) (*TakeHistoryMemo, error) {
	return c.Query().Where(takehistorymemo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TakeHistoryMemoClient) GetX(ctx context.Context, id uuid.UUID) *TakeHistoryMemo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TakeHistoryMemoClient) Hooks() []Hook {
	return c.hooks.TakeHistoryMemo
}

// Interceptors returns the client interceptors.
func (c *TakeHistoryMemoClient) Interceptors() []Interceptor {
	return c.inters.TakeHistoryMemo
}

func (c *TakeHistoryMemoClient) mutate(ctx context.Context, m *TakeHistoryMemoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TakeHistoryMemoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TakeHistoryMemoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TakeHistoryMemoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TakeHistoryMemoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TakeHistoryMemo mutation op: %q", m.Op())
	}
}

// TimeZoneClient is a client for the TimeZone schema.
type TimeZoneClient struct {
	config
}

// NewTimeZoneClient returns a client for the TimeZone from the given config.
func NewTimeZoneClient(c config) *TimeZoneClient {
	return &TimeZoneClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `timezone.Hooks(f(g(h())))`.
func (c *TimeZoneClient) Use(hooks ...Hook) {
	c.hooks.TimeZone = append(c.hooks.TimeZone, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `timezone.Intercept(f(g(h())))`.
func (c *TimeZoneClient) Intercept(interceptors ...Interceptor) {
	c.inters.TimeZone = append(c.inters.TimeZone, interceptors...)
}

// Create returns a builder for creating a TimeZone entity.
func (c *TimeZoneClient) Create() *TimeZoneCreate {
	mutation := newTimeZoneMutation(c.config, OpCreate)
	return &TimeZoneCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TimeZone entities.
func (c *TimeZoneClient) CreateBulk(builders ...*TimeZoneCreate) *TimeZoneCreateBulk {
	return &TimeZoneCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TimeZoneClient) MapCreateBulk(slice any, setFunc func(*TimeZoneCreate, int)) *TimeZoneCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TimeZoneCreateBulk{err: fmt.Errorf("calling to TimeZoneClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TimeZoneCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TimeZoneCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TimeZone.
func (c *TimeZoneClient) Update() *TimeZoneUpdate {
	mutation := newTimeZoneMutation(c.config, OpUpdate)
	return &TimeZoneUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TimeZoneClient) UpdateOne(tz *TimeZone) *TimeZoneUpdateOne {
	mutation := newTimeZoneMutation(c.config, OpUpdateOne, withTimeZone(tz))
	return &TimeZoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TimeZoneClient) UpdateOneID(id uuid.UUID) *TimeZoneUpdateOne {
	mutation := newTimeZoneMutation(c.config, OpUpdateOne, withTimeZoneID(id))
	return &TimeZoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TimeZone.
func (c *TimeZoneClient) Delete() *TimeZoneDelete {
	mutation := newTimeZoneMutation(c.config, OpDelete)
	return &TimeZoneDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TimeZoneClient) DeleteOne(tz *TimeZone) *TimeZoneDeleteOne {
	return c.DeleteOneID(tz.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TimeZoneClient) DeleteOneID(id uuid.UUID) *TimeZoneDeleteOne {
	builder := c.Delete().Where(timezone.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TimeZoneDeleteOne{builder}
}

// Query returns a query builder for TimeZone.
func (c *TimeZoneClient) Query() *TimeZoneQuery {
	return &TimeZoneQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTimeZone},
		inters: c.Interceptors(),
	}
}

// Get returns a TimeZone entity by its id.
func (c *TimeZoneClient) Get(ctx context.Context, id uuid.UUID) (*TimeZone, error) {
	return c.Query().Where(timezone.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TimeZoneClient) GetX(ctx context.Context, id uuid.UUID) *TimeZone {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TimeZoneClient) Hooks() []Hook {
	return c.hooks.TimeZone
}

// Interceptors returns the client interceptors.
func (c *TimeZoneClient) Interceptors() []Interceptor {
	return c.inters.TimeZone
}

func (c *TimeZoneClient) mutate(ctx context.Context, m *TimeZoneMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TimeZoneCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TimeZoneUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TimeZoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TimeZoneDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TimeZone mutation op: %q", m.Op())
	}
}

// TokenClient is a client for the Token schema.
type TokenClient struct {
	config
}

// NewTokenClient returns a client for the Token from the given config.
func NewTokenClient(c config) *TokenClient {
	return &TokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `token.Hooks(f(g(h())))`.
func (c *TokenClient) Use(hooks ...Hook) {
	c.hooks.Token = append(c.hooks.Token, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `token.Intercept(f(g(h())))`.
func (c *TokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.Token = append(c.inters.Token, interceptors...)
}

// Create returns a builder for creating a Token entity.
func (c *TokenClient) Create() *TokenCreate {
	mutation := newTokenMutation(c.config, OpCreate)
	return &TokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Token entities.
func (c *TokenClient) CreateBulk(builders ...*TokenCreate) *TokenCreateBulk {
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenClient) MapCreateBulk(slice any, setFunc func(*TokenCreate, int)) *TokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenCreateBulk{err: fmt.Errorf("calling to TokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Token.
func (c *TokenClient) Update() *TokenUpdate {
	mutation := newTokenMutation(c.config, OpUpdate)
	return &TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenClient) UpdateOne(t *Token) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withToken(t))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenClient) UpdateOneID(id int) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withTokenID(id))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Token.
func (c *TokenClient) Delete() *TokenDelete {
	mutation := newTokenMutation(c.config, OpDelete)
	return &TokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenClient) DeleteOne(t *Token) *TokenDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenClient) DeleteOneID(id int) *TokenDeleteOne {
	builder := c.Delete().Where(token.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenDeleteOne{builder}
}

// Query returns a query builder for Token.
func (c *TokenClient) Query() *TokenQuery {
	return &TokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToken},
		inters: c.Interceptors(),
	}
}

// Get returns a Token entity by its id.
func (c *TokenClient) Get(ctx context.Context, id int) (*Token, error) {
	return c.Query().Where(token.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenClient) GetX(ctx context.Context, id int) *Token {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TokenClient) Hooks() []Hook {
	return c.hooks.Token
}

// Interceptors returns the client interceptors.
func (c *TokenClient) Interceptors() []Interceptor {
	return c.inters.Token
}

func (c *TokenClient) mutate(ctx context.Context, m *TokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Token mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Medicine, Prescription, PrescriptionItem, TakeHistoryItem, TakeHistoryMemo,
		TimeZone, Token, User []ent.Hook
	}
	inters struct {
		Medicine, Prescription, PrescriptionItem, TakeHistoryItem, TakeHistoryMemo,
		TimeZone, Token, User []ent.Interceptor
	}
)
